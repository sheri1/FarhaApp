{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useState, useEffect } from 'react';\nimport DeprecatedUtils from \"./internal/deprecatedUtils\";\nimport DeprecatedState from \"./internal/deprecatedState\";\nimport * as DeprecatedTypes from \"./internal/deprecatedTypes\";\nimport State from \"./internal/state\";\nimport * as Types from \"./internal/types\";\nState.setup();\nDeprecatedState.setup();\n\nvar _isConnectedListeners = new Map();\n\nexport function fetch() {\n  return State.latest();\n}\nexport function addEventListener(listenerOrType) {\n  var deprecatedHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n  if (typeof listenerOrType === 'string') {\n    DeprecatedUtils.warnOnce();\n\n    if (listenerOrType === DeprecatedTypes.CHANGE_EVENT_NAME && deprecatedHandler) {\n      DeprecatedState.add(deprecatedHandler);\n      return {\n        remove: function remove() {\n          DeprecatedState.remove(deprecatedHandler);\n        }\n      };\n    } else {\n      return {\n        remove: function remove() {}\n      };\n    }\n  } else {\n    var _listener = listenerOrType;\n    State.add(_listener);\n    return function () {\n      State.remove(_listener);\n    };\n  }\n}\nexport function useNetInfo() {\n  var _useState = useState({\n    type: Types.NetInfoStateType.unknown,\n    isConnected: false,\n    isInternetReachable: false,\n    details: null\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      netInfo = _useState2[0],\n      setNetInfo = _useState2[1];\n\n  useEffect(function () {\n    return addEventListener(setNetInfo);\n  }, []);\n  return netInfo;\n}\nexport function removeEventListener(type, handler) {\n  DeprecatedUtils.warnOnce();\n\n  if (type === DeprecatedTypes.CHANGE_EVENT_NAME) {\n    DeprecatedState.remove(handler);\n  }\n}\nexport function getConnectionInfo() {\n  DeprecatedUtils.warnOnce();\n  return DeprecatedState.latest();\n}\nexport function isConnectionExpensive() {\n  DeprecatedUtils.warnOnce();\n  return State.latest().then(DeprecatedUtils.isConnectionExpensive);\n}\nexport var isConnected = {\n  addEventListener: function addEventListener(eventName, handler) {\n    if (eventName !== DeprecatedTypes.CHANGE_EVENT_NAME) {\n      return {\n        remove: function remove() {}\n      };\n    }\n\n    var listener = function listener(state) {\n      handler(DeprecatedUtils.isConnected(state));\n    };\n\n    _isConnectedListeners.set(handler, listener);\n\n    State.add(listener);\n    return {\n      remove: function remove() {\n        State.remove(listener);\n      }\n    };\n  },\n  removeEventListener: function removeEventListener(_eventName, handler) {\n    var listener = _isConnectedListeners.get(handler);\n\n    listener && State.remove(listener);\n\n    _isConnectedListeners.delete(handler);\n  },\n  fetch: function fetch() {\n    return State.latest().then(DeprecatedUtils.isConnected);\n  }\n};\nexport * from \"./internal/types\";\nexport * from \"./internal/deprecatedTypes\";\nexport default {\n  fetch: fetch,\n  addEventListener: addEventListener,\n  useNetInfo: useNetInfo,\n  removeEventListener: removeEventListener,\n  getConnectionInfo: getConnectionInfo,\n  isConnectionExpensive: isConnectionExpensive,\n  isConnected: isConnected\n};","map":{"version":3,"sources":["index.ts"],"names":["State","DeprecatedState","_isConnectedListeners","deprecatedHandler","undefined","DeprecatedUtils","listenerOrType","DeprecatedTypes","remove","listener","netInfo","setNetInfo","useState","type","Types","isConnected","isInternetReachable","details","useEffect","addEventListener","eventName","handler","removeEventListener","fetch","useNetInfo","getConnectionInfo","isConnectionExpensive"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport {useState, useEffect} from 'react';\nimport DeprecatedUtils from './internal/deprecatedUtils';\nimport DeprecatedState from './internal/deprecatedState';\nimport * as DeprecatedTypes from './internal/deprecatedTypes';\nimport State from './internal/state';\nimport * as Types from './internal/types';\n\n// Call the setup methods of the two state modules right away\nState.setup();\nDeprecatedState.setup();\n\nconst _isConnectedListeners = new Map<\n  DeprecatedTypes.IsConnectedHandler,\n  /// @ts-ignore Typescript des not like the trailing comma that Prettier insists upon\n  Types.NetInfoChangeHandler\n>();\n\n/**\n * Returns a `Promise` that resolves to a `NetInfoState` object.\n *\n * @returns A Promise which contains the current connection state.\n */\nexport function fetch(): Promise<Types.NetInfoState> {\n  return State.latest();\n}\n\n/**\n * Subscribe to connection information. The callback is called with a parameter of type\n * [`NetInfoState`](README.md#netinfostate) whenever the connection state changes. Your listener\n * will be called with the latest information soon after you subscribe and then with any\n * subsequent changes afterwards. You should not assume that the listener is called in the same\n * way across devices or platforms.\n *\n * @param listener The listener which is called when the network state changes.\n *\n * @returns An ofunction which can be called to unsubscribe.\n */\nexport function addEventListener(\n  listener: Types.NetInfoChangeHandler,\n): Types.NetInfoSubscription;\n\n/**\n * Deprecated network state listener. You should remove the event name and change your handler to\n * use the new state shape.\n *\n * @deprecated\n *\n * @param type The event type.\n * @param deprecatedHandler The listener.\n *\n * @returns An object with a remove function which can be called to unsubscribe.\n */\nexport function addEventListener(\n  type: string,\n  deprecatedHandler: DeprecatedTypes.ChangeHandler,\n): DeprecatedTypes.Subscription;\n\n// Implementation of the overloaded methods above\nexport function addEventListener(\n  listenerOrType: Types.NetInfoChangeHandler | string,\n  deprecatedHandler: DeprecatedTypes.ChangeHandler | undefined = undefined,\n): Types.NetInfoSubscription | DeprecatedTypes.Subscription {\n  if (typeof listenerOrType === 'string') {\n    DeprecatedUtils.warnOnce();\n\n    if (\n      listenerOrType === DeprecatedTypes.CHANGE_EVENT_NAME &&\n      deprecatedHandler\n    ) {\n      DeprecatedState.add(deprecatedHandler);\n      return {\n        remove: (): void => {\n          DeprecatedState.remove(deprecatedHandler);\n        },\n      };\n    } else {\n      return {\n        remove: (): void => {},\n      };\n    }\n  } else {\n    const listener = listenerOrType;\n    State.add(listener);\n    return (): void => {\n      State.remove(listener);\n    };\n  }\n}\n\n/**\n * A React Hook which updates when the connection state changes.\n *\n * @returns The connection state.\n */\nexport function useNetInfo(): Types.NetInfoState {\n  const [netInfo, setNetInfo] = useState<Types.NetInfoState>({\n    type: Types.NetInfoStateType.unknown,\n    isConnected: false,\n    isInternetReachable: false,\n    details: null,\n  });\n\n  useEffect((): (() => void) => {\n    return addEventListener(setNetInfo);\n  }, []);\n\n  return netInfo;\n}\n\n/**\n * Deprecated method to remove the listener. You should upgrade to the new API.\n *\n * @deprecated\n *\n * @param type The event type.\n * @param handler The event listener.\n */\nexport function removeEventListener(\n  type: string,\n  handler: DeprecatedTypes.ChangeHandler,\n): void {\n  DeprecatedUtils.warnOnce();\n\n  if (type === DeprecatedTypes.CHANGE_EVENT_NAME) {\n    DeprecatedState.remove(handler);\n  }\n}\n\n/**\n * Deprecated method to get the current state. You should upgrade to the new `fetch` method and\n * handle the new state type.\n *\n * @deprecated\n */\nexport function getConnectionInfo(): Promise<DeprecatedTypes.NetInfoData> {\n  DeprecatedUtils.warnOnce();\n  return DeprecatedState.latest();\n}\n\n/**\n * Deprecated method to tell if the current connection is \"expensive\". Only available on Android.\n * You should now call the `fetch` method and look at the `details.isConnectionExpensive` property.\n *\n * @deprecated\n */\nexport function isConnectionExpensive(): Promise<boolean> {\n  DeprecatedUtils.warnOnce();\n  return State.latest().then(DeprecatedUtils.isConnectionExpensive);\n}\n\nexport const isConnected = {\n  /**\n   * Deprecated method to listen for changes to the connected boolean. You should now use the\n   * normal `addEventListener` method and look at the `isConnected` property.\n   *\n   * @deprecated\n   */\n  addEventListener: (\n    eventName: string,\n    handler: DeprecatedTypes.IsConnectedHandler,\n  ): DeprecatedTypes.Subscription => {\n    if (eventName !== DeprecatedTypes.CHANGE_EVENT_NAME) {\n      return {remove: (): void => {}};\n    }\n\n    const listener = (state: Types.NetInfoState): void => {\n      handler(DeprecatedUtils.isConnected(state));\n    };\n\n    _isConnectedListeners.set(handler, listener);\n    State.add(listener);\n\n    return {\n      remove: (): void => {\n        State.remove(listener);\n      },\n    };\n  },\n\n  /**\n   * Deprecated method to stop listening for changes to the connected boolean. You should now use\n   * the normal `addEventListener` method and look at the `isConnected` property.\n   *\n   * @deprecated\n   */\n  removeEventListener: (\n    _eventName: string,\n    handler: DeprecatedTypes.IsConnectedHandler,\n  ): void => {\n    const listener = _isConnectedListeners.get(handler);\n    listener && State.remove(listener);\n    _isConnectedListeners.delete(handler);\n  },\n\n  /**\n   * Deprecated method to get the current is connected boolean. You should now use the normal\n   * `fetch` method and look at the `isConnected` property.\n   *\n   * @deprecated\n   */\n  fetch: (): Promise<boolean> => {\n    return State.latest().then(DeprecatedUtils.isConnected);\n  },\n};\n\nexport * from './internal/types';\nexport * from './internal/deprecatedTypes';\n\nexport default {\n  fetch,\n  addEventListener,\n  useNetInfo,\n  removeEventListener,\n  getConnectionInfo,\n  isConnectionExpensive,\n  isConnected,\n};\n"]},"metadata":{},"sourceType":"module"}