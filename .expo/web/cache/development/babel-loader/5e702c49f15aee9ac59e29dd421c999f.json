{"ast":null,"code":"var REACHABILITY_URL = 'https://clients3.google.com/generate_204';\nvar LONG_TIMEOUT = 60 * 1000;\nvar SHORT_TIMEOUT = 5 * 1000;\n\nvar _subscriptions = new Set();\n\nvar _isInternetReachable = null;\nvar _currentInternetReachabilityCheckHandler = null;\nvar _currentTimeoutHandle = null;\n\nfunction setIsInternetReachable(isInternetReachable) {\n  if (_isInternetReachable === isInternetReachable) {\n    return;\n  }\n\n  _isInternetReachable = isInternetReachable;\n\n  _subscriptions.forEach(function (listener) {\n    listener(_isInternetReachable);\n  });\n}\n\nfunction checkInternetReachability() {\n  var hasCanceled = false;\n  var promise = fetch(REACHABILITY_URL).then(function (response) {\n    if (!hasCanceled) {\n      setIsInternetReachable(response.status === 204);\n      var nextTimeoutInterval = _isInternetReachable ? LONG_TIMEOUT : SHORT_TIMEOUT;\n      _currentTimeoutHandle = setTimeout(checkInternetReachability, nextTimeoutInterval);\n    }\n  }).catch(function () {\n    setIsInternetReachable(false);\n    _currentTimeoutHandle = setTimeout(checkInternetReachability, SHORT_TIMEOUT);\n  });\n  return {\n    promise: promise,\n    cancel: function cancel() {\n      hasCanceled = true;\n    }\n  };\n}\n\nfunction setExpectsConnection(expectsConnection) {\n  if (_currentInternetReachabilityCheckHandler !== null) {\n    _currentInternetReachabilityCheckHandler.cancel();\n\n    _currentInternetReachabilityCheckHandler = null;\n  }\n\n  if (_currentTimeoutHandle !== null) {\n    clearTimeout(_currentTimeoutHandle);\n    _currentTimeoutHandle = null;\n  }\n\n  if (expectsConnection) {\n    if (!_isInternetReachable) {\n      setIsInternetReachable(null);\n    }\n\n    _currentInternetReachabilityCheckHandler = checkInternetReachability();\n  } else {\n    setIsInternetReachable(false);\n  }\n}\n\nexport function clear() {\n  if (_currentInternetReachabilityCheckHandler !== null) {\n    _currentInternetReachabilityCheckHandler.cancel();\n\n    _currentInternetReachabilityCheckHandler = null;\n  }\n\n  if (_currentTimeoutHandle !== null) {\n    clearTimeout(_currentTimeoutHandle);\n    _currentTimeoutHandle = null;\n  }\n\n  _subscriptions.clear();\n}\nexport function update(state) {\n  if (typeof state.isInternetReachable === 'boolean') {\n    setIsInternetReachable(state.isInternetReachable);\n  } else {\n    setExpectsConnection(state.isConnected);\n  }\n}\nexport function currentState() {\n  return _isInternetReachable;\n}\nexport function addSubscription(listener) {\n  _subscriptions.add(listener);\n\n  return function () {\n    _subscriptions.delete(listener);\n  };\n}\nexport default {\n  update: update,\n  currentState: currentState,\n  clear: clear,\n  addSubscription: addSubscription\n};","map":{"version":3,"sources":["internetReachability.ts"],"names":["REACHABILITY_URL","LONG_TIMEOUT","SHORT_TIMEOUT","_subscriptions","_isInternetReachable","_currentInternetReachabilityCheckHandler","_currentTimeoutHandle","listener","hasCanceled","promise","fetch","setIsInternetReachable","response","nextTimeoutInterval","setTimeout","cancel","clearTimeout","checkInternetReachability","state","setExpectsConnection","update","currentState","clear","addSubscription"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n */\n\nimport * as PrivateTypes from './privateTypes';\n\nconst REACHABILITY_URL = 'https://clients3.google.com/generate_204';\nconst LONG_TIMEOUT = 60 * 1000; // 60s\nconst SHORT_TIMEOUT = 5 * 1000; // 5s\n\nconst _subscriptions = new Set<\n  PrivateTypes.NetInfoInternetReachabilityChangeListener\n>();\nlet _isInternetReachable: boolean | null = null;\nlet _currentInternetReachabilityCheckHandler: InternetReachabilityCheckHandler | null = null;\nlet _currentTimeoutHandle: number | null = null;\n\nfunction setIsInternetReachable(isInternetReachable: boolean | null): void {\n  if (_isInternetReachable === isInternetReachable) {\n    return;\n  }\n\n  _isInternetReachable = isInternetReachable;\n  _subscriptions.forEach(\n    (listener): void => {\n      listener(_isInternetReachable);\n    },\n  );\n}\n\ninterface InternetReachabilityCheckHandler {\n  promise: Promise<void>;\n  cancel: () => void;\n}\nfunction checkInternetReachability(): InternetReachabilityCheckHandler {\n  // We wraop the promise to allow us to cancel the pending request, if needed\n  let hasCanceled = false;\n\n  const promise = fetch(REACHABILITY_URL)\n    .then(\n      (response): void => {\n        if (!hasCanceled) {\n          setIsInternetReachable(response.status === 204);\n          const nextTimeoutInterval = _isInternetReachable\n            ? LONG_TIMEOUT\n            : SHORT_TIMEOUT;\n          _currentTimeoutHandle = setTimeout(\n            checkInternetReachability,\n            nextTimeoutInterval,\n          );\n        }\n      },\n    )\n    .catch(\n      (): void => {\n        setIsInternetReachable(false);\n        _currentTimeoutHandle = setTimeout(\n          checkInternetReachability,\n          SHORT_TIMEOUT,\n        );\n      },\n    );\n\n  return {\n    promise,\n    cancel: (): void => {\n      hasCanceled = true;\n    },\n  };\n}\n\nfunction setExpectsConnection(expectsConnection: boolean): void {\n  // Cancel any pending check\n  if (_currentInternetReachabilityCheckHandler !== null) {\n    _currentInternetReachabilityCheckHandler.cancel();\n    _currentInternetReachabilityCheckHandler = null;\n  }\n  // Cancel any pending timeout\n  if (_currentTimeoutHandle !== null) {\n    clearTimeout(_currentTimeoutHandle);\n    _currentTimeoutHandle = null;\n  }\n\n  if (expectsConnection) {\n    // If we expect a connection, start the process for finding if we have one\n    // Set the state to \"null\" if it was previously false\n    if (!_isInternetReachable) {\n      setIsInternetReachable(null);\n    }\n    // Start a network request to check for internet\n    _currentInternetReachabilityCheckHandler = checkInternetReachability();\n  } else {\n    // If we don't expect a connection, just change the state to \"false\"\n    setIsInternetReachable(false);\n  }\n}\n\nexport function clear(): void {\n  // Cancel any pending check\n  if (_currentInternetReachabilityCheckHandler !== null) {\n    _currentInternetReachabilityCheckHandler.cancel();\n    _currentInternetReachabilityCheckHandler = null;\n  }\n\n  // Cancel any pending timeout\n  if (_currentTimeoutHandle !== null) {\n    clearTimeout(_currentTimeoutHandle);\n    _currentTimeoutHandle = null;\n  }\n\n  // Clear the subscriptions\n  _subscriptions.clear();\n}\n\nexport function update(state: PrivateTypes.NetInfoNativeModuleState): void {\n  if (typeof state.isInternetReachable === 'boolean') {\n    setIsInternetReachable(state.isInternetReachable);\n  } else {\n    setExpectsConnection(state.isConnected);\n  }\n}\n\nexport function currentState(): boolean | null {\n  return _isInternetReachable;\n}\n\nexport function addSubscription(\n  listener: PrivateTypes.NetInfoInternetReachabilityChangeListener,\n): () => void {\n  _subscriptions.add(listener);\n\n  return (): void => {\n    _subscriptions.delete(listener);\n  };\n}\n\nexport default {\n  update,\n  currentState,\n  clear,\n  addSubscription,\n};\n"]},"metadata":{},"sourceType":"module"}